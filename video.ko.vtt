WEBVTT
Kind: captions
Language:  ko

00:00:00.450 --> 00:00:04.340
이 동영상에서는 펄스 도플러 레이더를 소개합니다.

00:00:04.340 --> 00:00:07.470
구체적으로 말해, 일련의 레이더 펄스를 사용하여

00:00:07.490 --> 00:00:11.370
거리와 시선 속도를 판단하는 방법에 대해 설명하겠습니다.

00:00:11.370 --> 00:00:13.370
정말 재미있을 것 같아요.

00:00:13.370 --> 00:00:16.000
그래픽을 활용한 설명을 통해 여러분이 앞으로

00:00:16.010 --> 00:00:19.000
지식을 쌓는 데 필요한 기반을 다졌으면 합니다.

00:00:19.000 --> 00:00:21.770
그러니 동영상을 끝까지 시청해 주시기 바랍니다.

00:00:21.770 --> 00:00:22.686
저는 Brian입니다.

00:00:22.686 --> 00:00:24.770
MATLAB Tech Talk에 오신 것을 환영합니다.

00:00:26.550 --> 00:00:29.521
이름에서 알 수 있듯이 펄스 레이더 시스템은

00:00:29.520 --> 00:00:32.266
고에너지 파형의 짧은 버스트 또는 펄스를 내보냅니다.

00:00:32.400 --> 00:00:35.520
그리고 수신기가 반사된 신호를 듣는

00:00:35.525 --> 00:00:37.330
긴 침묵의 시간이 이어지죠.

00:00:37.330 --> 00:00:42.200
펄스 레이더로 전송된 파형은 이렇게 보일 것입니다.

00:00:42.200 --> 00:00:44.350
처음에는 송신기가 침묵하고 신호가

00:00:44.360 --> 00:00:46.530
송신되지 않는 기간이 있습니다.

00:00:46.530 --> 00:00:48.850
이어서 펄스가 시작될 때 송신기가

00:00:48.860 --> 00:00:51.330
IQ 신호를 송신하기 시작합니다.

00:00:51.330 --> 00:00:55.930
펄스 내에서 사용할 수 있는 다양한 변조 체계가 있지만

00:00:55.930 --> 00:01:00.400
여기서는 2.8GHz의 고정 주파수를 보여주고 있습니다.

00:01:00.400 --> 00:01:04.800
따라서 펄스 동안 2.8GHz 신호가 일정하게 전송됩니다.

00:01:05.600 --> 00:01:07.650
레이더는 펄스 폭이라고 부르는

00:01:07.670 --> 00:01:10.130
일정 시간 동안 이를 송신합니다.

00:01:10.130 --> 00:01:14.930
이 예제에서는 1마이크로초의 펄스 폭을 사용합니다.

00:01:15.660 --> 00:01:19.022
신호가 이 펄스 내에서 2,800번 진동하기 때문에

00:01:19.022 --> 00:01:22.060
이 분해능에서는 고체 블록처럼 보입니다.

00:01:22.060 --> 00:01:25.310
신호 자체를 보여주는 대신 펄스를

00:01:25.320 --> 00:01:29.130
신호 진폭의 윤곽으로 표현하겠습니다.

00:01:29.130 --> 00:01:33.420
펄스가 켜지고 꺼짐에 따라 신호의 진폭이 직사각형을

00:01:33.430 --> 00:01:39.130
형성하기 때문에 이 고정 주파수 체계를 직사각형 펄스라고 합니다.

00:01:40.060 --> 00:01:43.474
이제 펄스 레이더 시스템에서는 펄스가 방출되어

00:01:43.474 --> 00:01:44.846
객체에서 반사되고,

00:01:44.846 --> 00:01:48.800
다음 펄스가 전송되기 전에 레이더로 반환되어야 합니다.

00:01:48.800 --> 00:01:50.650
에코가 어느 펄스에 속하는지가

00:01:50.660 --> 00:01:53.000
모호하지 않도록 하기 위해서입니다.

00:01:53.000 --> 00:01:55.460
에코는 항상 방금 송신된 펄스에 속합니다.

00:01:55.460 --> 00:01:57.181
하지만 이러한 이유로,

00:01:57.181 --> 00:02:00.768
공항 레이더와 같이 장거리에서 작동할 수 있는

00:02:00.768 --> 00:02:02.425
레이더를 설계할 때는

00:02:02.425 --> 00:02:05.896
객체를 오가는 빛의 속도를 감안할 수 있도록

00:02:05.896 --> 00:02:09.200
펄스 사이에 충분한 시간을 두어야 합니다.

00:02:11.400 --> 00:02:15.410
여기서는 1밀리초마다, 즉 1kHz의 펄스

00:02:15.420 --> 00:02:20.330
반복 주파수(PRF)로 펄스를 내보내고 있습니다.

00:02:21.400 --> 00:02:25.840
PRF가 1kHz이고 펄스 폭이 1마이크로초일 때

00:02:25.850 --> 00:02:30.800
이 시스템의 최대 유효 거리는 150km 미만입니다.

00:02:30.800 --> 00:02:35.860
또는 빛이 999마이크로초 안에 객체까지의 왕복 거리인

00:02:35.870 --> 00:02:41.460
약 300km를 이동한다는 사실을 생각해볼 수도 있습니다.

00:02:41.460 --> 00:02:44.060
이것이 펄스 사이의 데드 타임입니다.

00:02:45.800 --> 00:02:48.832
레이더 시야에 있는 단일 객체가

00:02:48.832 --> 00:02:52.317
150km 미만의 거리에 있다고 가정하면,

00:02:52.317 --> 00:02:56.660
각 펄스는 관련된 에코 펄스를 가질 것입니다.

00:02:56.660 --> 00:02:58.672
지난 동영상에서 이야기했듯이,

00:02:58.672 --> 00:03:01.041
많은 전력이 환경에 손실되기 때문에

00:03:01.041 --> 00:03:03.800
이 신호들은 송신 펄스보다 훨씬 약합니다.

00:03:03.800 --> 00:03:06.620
또한 객체가 시선 속도를 가진 경우

00:03:06.640 --> 00:03:09.930
반사 신호의 주파수가 약간 이동합니다.

00:03:09.930 --> 00:03:11.950
FMCW 레이더를 떠올려보면,

00:03:11.950 --> 00:03:14.715
아주 작은 주파수 이동을 이용해서

00:03:14.715 --> 00:03:17.060
비트 주파수를 만들었습니다.

00:03:17.060 --> 00:03:20.660
그리고 거기서 속도를 알아낼 수 있었죠.

00:03:20.660 --> 00:03:24.926
이번에는 이 펄스 도플러 레이더 시스템으로 속도를 판단하는

00:03:24.926 --> 00:03:27.583
약간 다른 접근 방식을 취할 것입니다.

00:03:27.583 --> 00:03:31.186
여기서는 주파수 이동을 직접 측정하는 것이 아니라

00:03:31.186 --> 00:03:33.800
펄스 사이의 위상 이동을 확인합니다.

00:03:33.800 --> 00:03:36.460
이 내용을 다루기에 앞서

00:03:36.460 --> 00:03:39.530
거리 판단에 대해 이야기해 보겠습니다.

00:03:40.600 --> 00:03:42.760
수신 신호 중 하나를 확대해

00:03:42.770 --> 00:03:45.530
보면, 이렇게 보일 수 있습니다.

00:03:45.530 --> 00:03:49.060
펄스가 전송되고 나면 수신기가 듣기 시작합니다.

00:03:49.060 --> 00:03:51.330
펄스가 돌아오기도 전에, 전자 기기와

00:03:51.340 --> 00:03:54.660
환경으로부터 어느 정도의 노이즈가 발생할 것입니다.

00:03:54.660 --> 00:03:57.280
반사 신호가 돌아올 때, 반사 신호는

00:03:57.290 --> 00:03:59.800
노이즈보다 훨씬 더 커야 합니다.

00:03:59.800 --> 00:04:01.690
이제 우리는 펄스가 송신된 시간과 펄스가

00:04:01.700 --> 00:04:04.130
돌아오는 시간 사이의 시간을 판단할 수 있습니다.

00:04:04.730 --> 00:04:08.500
객체까지의 거리는 빛이 그 시간 동안

00:04:08.510 --> 00:04:13.060
이동했을 왕복 거리를 판단하여 계산합니다.

00:04:13.060 --> 00:04:15.930
여기서 제가 특히 강조하고 싶은 것은 두 가지입니다.

00:04:15.930 --> 00:04:18.720
첫째, 펄스는 단일 시점이 아니라 시간의 폭을

00:04:18.730 --> 00:04:21.660
가지고 있으며 이 경우에는 1마이크로초입니다.

00:04:21.660 --> 00:04:23.401
그리고 빛은 그 시간 동안

00:04:23.401 --> 00:04:25.400
약 300m를 이동할 수 있습니다.

00:04:25.400 --> 00:04:28.042
더 높은 정확도를 원한다면 펄스가 정확하게

00:04:28.042 --> 00:04:31.431
1마이크로초 미만으로 돌아오는 시간을 확인하는 방법을

00:04:31.431 --> 00:04:33.060
생각해내는 것이 좋습니다.

00:04:33.060 --> 00:04:36.417
여기서 보여드리는 것처럼 객체가 가까이 있고 반사된

00:04:36.417 --> 00:04:37.968
신호 전력이 정말 높다면

00:04:37.968 --> 00:04:40.660
펄스를 찾기가 그리 어렵지 않을 것입니다.

00:04:40.660 --> 00:04:42.940
하지만 아시다시피, 신호 전력은

00:04:42.950 --> 00:04:46.330
객체까지의 거리를 4제곱한 만큼 떨어집니다.

00:04:46.330 --> 00:04:48.678
그래서 객체가 멀어질수록

00:04:48.678 --> 00:04:52.571
신호가 노이즈를 벗어나기가 어려워집니다.

00:04:52.571 --> 00:04:56.582
그래서 제가 두 번째로 이야기하고 싶은 것은

00:04:56.582 --> 00:05:02.000
신호 대 노이즈 비율과 객체를 탐지할 수 있는 임계값입니다.

00:05:02.000 --> 00:05:04.821
탐지 가능성 임계값을 설정할 때는

00:05:04.821 --> 00:05:08.763
무작위 노이즈 스파이크를 지속적으로 객체라고

00:05:08.763 --> 00:05:12.359
여기지 않을 정도로 거짓 탐지 확률이 낮고,

00:05:12.359 --> 00:05:18.130
신호를 완전히 놓칠 정도로 높지 않은 수준으로 임계값을 설정합니다.

00:05:18.130 --> 00:05:21.488
일정한 거짓 경보 비율, 줄여서 CFAR은 필요한

00:05:21.488 --> 00:05:23.947
거짓 경보 확률을 달성하기 위해

00:05:23.947 --> 00:05:26.608
이 임계값을 설정하는 데 사용되는

00:05:26.608 --> 00:05:29.800
적응형 알고리즘의 일반적인 형태입니다.

00:05:30.730 --> 00:05:34.996
탐지 가능성을 높이고 거짓 경보의 가능성을 줄이기 위해서는

00:05:34.996 --> 00:05:38.198
노이즈를 기준으로 신호를 증폭시키는 방법을

00:05:38.198 --> 00:05:40.460
찾아야 한다는 것이 명백합니다.

00:05:40.460 --> 00:05:44.600
한 가지 방법은 정합 필터를 사용하는 것입니다.

00:05:45.600 --> 00:05:49.268
정합 필터에 대한 더 길고 자세한 설명이 나와 있는

00:05:49.268 --> 00:05:53.530
링크를 아래에 남겼지만 여기서 간단히 요약해 보겠습니다.

00:05:54.130 --> 00:05:57.200
우리는 송신된 펄스의 패턴을 알고 있습니다.

00:05:57.200 --> 00:05:59.400
이 경우에는 직사각형 펄스죠.

00:05:59.400 --> 00:06:01.854
이 방정식에서는 필터 h로 표현됩니다.

00:06:01.854 --> 00:06:04.964
또한 우리는 펄스가 객체에 의해 반사되기 때문에

00:06:04.964 --> 00:06:07.011
펄스가 수신될 때도 이와 동일한

00:06:07.011 --> 00:06:09.730
일반적인 모양이 될 것임을 알고 있습니다.

00:06:09.860 --> 00:06:13.530
그리고 앞서 말했듯이, 노이즈가 있겠죠.

00:06:13.530 --> 00:06:19.260
하지만 신호 자체만 고려한다면, 직사각형 모양입니다.

00:06:19.660 --> 00:06:23.200
수신 신호는 이 방정식에서 x입니다.

00:06:23.200 --> 00:06:28.410
시간이 반전된 h를 x에 곱한 다음 그 결과를 합산하면

00:06:28.420 --> 00:06:34.530
h와 x 사이의 강한 상관관계의 영역을 증폭시킬 수 있습니다.

00:06:34.530 --> 00:06:37.060
그래픽으로 보면 이런 식입니다.

00:06:37.060 --> 00:06:39.396
우리는 시간에서 전송 펄스를 뒤집었습니다.

00:06:39.396 --> 00:06:42.049
이 경우에는 이 축을 따라 대칭을 이루기 때문에

00:06:42.049 --> 00:06:43.130
정확히 똑같습니다.

00:06:43.130 --> 00:06:45.030
그다음 이것을 샘플링된 수신

00:06:45.040 --> 00:06:47.600
신호와 곱하고 그 결과를 합합니다.

00:06:48.330 --> 00:06:53.000
여기 필터 중앙에 있는 이 x는 합계 값이며,

00:06:53.020 --> 00:06:58.460
현재 시간은 이 오른쪽 끝에 실제로 있을 것입니다.

00:06:58.460 --> 00:07:01.530
하지만 처리 과정에서 일반적으로 필터의 폭을 고려하고,

00:07:01.530 --> 00:07:04.656
여기서 보시다시피 결과를 오프셋하여 수신 펄스의 피크가

00:07:04.656 --> 00:07:06.660
시간 내에서 이동하지 않도록 합니다.

00:07:06.660 --> 00:07:08.560
이것은 거리를 판단하는 데 사용하는

00:07:08.570 --> 00:07:10.600
피크의 위치라는 사실을 기억하세요.

00:07:10.600 --> 00:07:15.000
따라서 동일한 위치에 있되 더 좁아져야 합니다.

00:07:15.800 --> 00:07:17.730
여기서 시작할 때 결과는 0입니다.

00:07:17.730 --> 00:07:20.168
이 시점에서는 수신 신호가 없기 때문에,

00:07:20.168 --> 00:07:21.930
완벽하게 노이즈도 없습니다.

00:07:21.930 --> 00:07:25.730
따라서 펄스에 이 값을 곱하면 0이 되죠.

00:07:26.330 --> 00:07:29.330
이제 필터를 다음 샘플 시간으로 이동하는 것을 반복합니다.

00:07:29.330 --> 00:07:35.200
수신된 신호 전체를 모두 거쳐 갈 때까지 계속 반복하죠.

00:07:36.330 --> 00:07:41.070
이 작업은 넓은 직사각형을 하나의 피크가 있는 삼각형으로

00:07:41.080 --> 00:07:46.600
바꿔 신호를 증폭시키고 신호를 더 좁게 만드는 효과가 있습니다.

00:07:46.600 --> 00:07:50.440
정합 필터가 펄스 압축이라고도 불리는 이유죠.

00:07:50.450 --> 00:07:54.460
넓은 펄스를 좁은 펄스로 압축하기 때문입니다.

00:07:54.930 --> 00:07:59.198
이런 종류의 필터는 노이즈보다 신호를 더 증폭시킵니다.

00:07:59.198 --> 00:08:03.324
펄스와 수신 신호 사이에는 완벽한 상관관계가 있는 반면

00:08:03.324 --> 00:08:06.860
무작위 노이즈와의 상관관계는 낮기 때문입니다.

00:08:07.130 --> 00:08:09.717
노이즈가 많은 반환 신호로 돌아가서,

00:08:09.717 --> 00:08:12.792
정합 필터를 신호에 적용하면 사실 노이즈가

00:08:12.792 --> 00:08:15.981
어느 정도 증폭된다는 사실을 알 수 있습니다.

00:08:15.981 --> 00:08:18.400
여러 개의 값을 합하고 있으니까요.

00:08:18.400 --> 00:08:20.720
그러나 필터는 펄스와 일치하기

00:08:20.730 --> 00:08:23.660
때문에  합이 펄스보다도 더 크며,

00:08:23.660 --> 00:08:27.460
노이즈 이득에 비해 신호 이득이 더 증가합니다.

00:08:27.460 --> 00:08:29.760
하지만 중요한 것은 SNR이 개선되었을

00:08:29.770 --> 00:08:32.530
뿐만 아니라 펄스 자체가 더 좁아졌기 때문에

00:08:32.530 --> 00:08:36.130
정확한 피크를 찾는 것도 쉬워진다는 겁니다.

00:08:36.800 --> 00:08:39.250
이제 정합 필터의 처리 이득을 감안하기

00:08:39.270 --> 00:08:42.330
위해 탐지 가능성 임계값을 높일 수 있습니다.

00:08:42.330 --> 00:08:44.303
보시다시피 노이즈와 신호 사이에

00:08:44.303 --> 00:08:46.890
더 많은 분리가 있다는 사실을 알 수 있으며,

00:08:46.890 --> 00:08:49.930
이로 인해 잠재적으로 거짓 탐지율이 더 낮아집니다.

00:08:51.200 --> 00:08:54.140
하지만 펄스 압축을 사용하더라도 신호 피크가

00:08:54.150 --> 00:08:57.730
탐지 가능성 임계값을 초과하리라는 보장은 없습니다.

00:08:57.730 --> 00:09:00.100
따라서 이 신호들을 노이즈로부터 증폭시킬

00:09:00.110 --> 00:09:02.930
수 있는 다른 방법을 찾아야 할지도 모릅니다.

00:09:02.930 --> 00:09:06.778
한 가지 방법은 여러 개의 펄스를 한 줄로 통합하고

00:09:06.778 --> 00:09:10.510
신호가 탐지 가능한 임계값 이상으로 상승할 때까지

00:09:10.510 --> 00:09:13.600
각 펄스의 모든 에너지를 합치는 것입니다.

00:09:14.800 --> 00:09:16.930
그래픽으로 보면 이런 식입니다.

00:09:16.930 --> 00:09:18.770
이것이 펄스 압축 후 수신기에서

00:09:18.780 --> 00:09:21.400
확인되는 신호 전력의 양이라고 가정합시다.

00:09:22.060 --> 00:09:25.800
그러나 이 신호는 노이즈에 의해 덮이고 맙니다.

00:09:25.800 --> 00:09:30.400
이것이 정합 필터 이후의 실제 수신 전력입니다.

00:09:30.400 --> 00:09:32.556
수신 신호 전체를 살펴보면

00:09:32.556 --> 00:09:36.930
펄스가 정확히 어디에 있는지 말하기가 좀 어렵습니다.

00:09:36.930 --> 00:09:39.670
하지만 이 신호를 버퍼에 저장한 다음 다른 펄스가

00:09:39.690 --> 00:09:42.860
돌아올 때까지 기다릴 수 있기 때문에 희망은 있습니다.

00:09:43.260 --> 00:09:46.060
두 번째 펄스도 노이즈에 의해 덮입니다.

00:09:46.060 --> 00:09:48.800
여전히 신호를 보기가 어렵습니다.

00:09:48.800 --> 00:09:53.240
하지만 이 두 펄스를 합치면 이 통합된 신호에서 노이즈를

00:09:53.250 --> 00:09:58.000
벗어난 명백한 피크가 조금 있다는 사실을 알 수 있습니다.

00:09:58.000 --> 00:09:59.827
이것이 효과가 있는 이유는

00:09:59.827 --> 00:10:03.330
노이즈가 펄스 간에는 상관관계가 없기 때문입니다.

00:10:03.330 --> 00:10:05.339
첫 번째 펄스의 특정 시점에

00:10:05.339 --> 00:10:08.126
노이즈가 비정상적으로 높았다고 해도

00:10:08.126 --> 00:10:12.130
다음 시점에서는 무작위적으로 낮을 수 있다는 뜻이죠.

00:10:12.130 --> 00:10:14.950
이들을 합치면, 상관관계가 없는 노이즈에

00:10:14.960 --> 00:10:17.930
대한 평균적인 증가를 얻을 수 있습니다.

00:10:18.200 --> 00:10:22.400
그러나 펄스에서 펄스로의 신호는 상관관계가 있습니다.

00:10:22.400 --> 00:10:24.620
그래서 다른 펄스를 합칠 때마다

00:10:24.630 --> 00:10:27.260
항상 같은 양의 신호를 추가합니다.

00:10:28.060 --> 00:10:31.740
신호가 탐지 가능성 임계값 이상으로

00:10:31.750 --> 00:10:37.000
올라갈 때까지 펄스를 계속 통합할 수 있습니다.

00:10:37.000 --> 00:10:39.860
이 시점에서는 이 피크의 시간을 찾을 수

00:10:39.870 --> 00:10:43.530
있으며, 그것으로부터 거리를 판단할 수 있습니다.

00:10:44.460 --> 00:10:46.192
여기서는 객체까지의 거리가

00:10:46.192 --> 00:10:49.930
펄스에 따라 변하지 않는다고 가정한다는 사실에 주목하세요.

00:10:49.930 --> 00:10:54.000
매번 피크가 같은 위치에 있을 것으로 예상하기 때문에 그렇습니다.

00:10:54.000 --> 00:10:57.390
이 가정은 꽤 효과적입니다. 여기서는

00:10:57.400 --> 00:11:01.660
펄스 사이의 시간이 1밀리초이기 때문입니다.

00:11:01.660 --> 00:11:04.800
10개의 펄스가 9밀리초 차이로 분리되죠.

00:11:04.800 --> 00:11:08.000
9밀리초 안에 객체가 얼마나 이동할 수 있을까요?

00:11:08.000 --> 00:11:11.530
만약 객체가 초당 180m로 이동한다면 시속

00:11:11.540 --> 00:11:16.860
400마일과 같은데, 이 경우 약 1.5m를 이동했을 것입니다.

00:11:16.860 --> 00:11:19.390
따라서 첫 번째 펄스와 10번째 펄스

00:11:19.400 --> 00:11:22.330
사이의 왕복 거리는 3m 더 길어집니다.

00:11:22.330 --> 00:11:25.800
빛의 속도의 경우, 3m는 약 10나노초가 걸립니다.

00:11:25.800 --> 00:11:28.790
우리의 펄스 폭은 1마이크로초이기 때문에,

00:11:28.800 --> 00:11:32.600
펄스는 여전히 본질적으로 완벽하게 정렬될 것입니다.

00:11:33.330 --> 00:11:37.590
이제 정합 필터와 펄스 통합이 반환 신호를 좁히고 노이즈에서

00:11:37.600 --> 00:11:42.000
신호를 끄집어내는 데 어떤 도움을 주는지 이해하셨기를 바랍니다.

00:11:42.000 --> 00:11:45.190
여기서부터는 전송된 펄스와 반환된 피크 사이의

00:11:45.200 --> 00:11:48.930
시간을 확인하기만 하면 거리를 계산할 수 있습니다.

00:11:48.930 --> 00:11:52.860
참고로, 이 데이터는 수평 축에 걸친 시간

00:11:52.870 --> 00:11:57.330
단위와 수직 축에 걸친 시간 단위가 있습니다.

00:11:57.330 --> 00:12:00.373
수평 축은 펄스 폭만 포함하기 때문에

00:12:00.373 --> 00:12:05.060
고속 시간이라고 부르며, 이 경우에는 1마이크로초입니다.

00:12:05.060 --> 00:12:07.954
수직 축은 저속 시간이라고 부르는데,

00:12:07.954 --> 00:12:11.460
펄스 사이의 더 긴 시간을 포함하기 때문이며

00:12:11.460 --> 00:12:13.860
이 경우에는 약 9밀리초입니다.

00:12:13.860 --> 00:12:17.750
거리를 측정할 때는 고속 시간 축을 가로질러

00:12:17.760 --> 00:12:23.460
수행하지만, 펄스를 통합할 때는 저속 시간 축을 가로지릅니다.

00:12:24.530 --> 00:12:27.933
이제 거리에서 넘어가서, 시선 속도를 측정하기 위해

00:12:27.933 --> 00:12:32.260
우리가 수집한 이 데이터를 사용하는 방법에 대해 살펴보겠습니다.

00:12:32.260 --> 00:12:35.780
이를 위해 이 저속 시간 축을 가로지르는,

00:12:35.790 --> 00:12:39.800
펄스에서 펄스까지의 데이터를 비교할 것입니다.

00:12:42.000 --> 00:12:44.810
여기 이것을 반환된 단일 펄스의

00:12:44.830 --> 00:12:47.660
IQ 신호라고 상상해 보세요.

00:12:47.660 --> 00:12:49.380
단순한 설명을 위해, 수신기에서 노이즈가

00:12:49.390 --> 00:12:51.130
전혀 발생하지 않는다고 가정하겠습니다.

00:12:51.130 --> 00:12:54.400
펄스가 송신된 후, 펄스가 객체로 이동했다가

00:12:54.410 --> 00:12:58.530
다시 돌아오는 동안 수신 신호는 완벽하게 무음입니다.

00:12:58.530 --> 00:13:01.460
그러다가 반사 펄스가 수신되죠.

00:13:01.460 --> 00:13:05.176
다시 말하지만 전송 펄스와 수신 펄스 사이의 시간은

00:13:05.176 --> 00:13:07.460
객체의 거리와 관련이 있습니다.

00:13:07.730 --> 00:13:09.824
객체가 움직이지 않는다면,

00:13:09.824 --> 00:13:14.130
두 개의 연속적인 펄스 사이의 거리는 정확히 같습니다.

00:13:14.130 --> 00:13:16.610
또한 송신 신호가 일관성(coherent)이

00:13:16.620 --> 00:13:19.530
있다면, 반환된 펄스도 서로와 동위상일 것입니다.

00:13:19.530 --> 00:13:23.330
세 번째 펄스도, 네 번째 펄스도 마찬가지죠.

00:13:23.330 --> 00:13:25.970
정지된 객체에서 반사되는 각각의

00:13:25.980 --> 00:13:29.260
반환된 펄스는 기본적으로 동일합니다.

00:13:29.260 --> 00:13:32.855
따라서 펄스가 전송된 시점과 비교하여

00:13:32.855 --> 00:13:36.969
같은 시점에 반환 펄스를 샘플링하여 측정된

00:13:36.969 --> 00:13:40.460
IQ 값을 플롯하면 이런 모양이 됩니다.

00:13:41.600 --> 00:13:43.930
이제 이 새로운 신호의 주파수를

00:13:43.950 --> 00:13:47.130
보고 객체의 속도를 판단할 수 있습니다.

00:13:47.130 --> 00:13:49.460
이 경우에는 두 개의 평평한 선만 있고,

00:13:49.460 --> 00:13:53.130
주파수는 0Hz, 속도는 시속 0마일입니다.

00:13:53.730 --> 00:13:55.850
하지만 만약 객체가 레이더에서

00:13:55.860 --> 00:13:58.660
멀어지면 어떻게 될지 생각해 봅시다.

00:13:58.660 --> 00:14:01.570
그럴 경우, 객체는 첫 번째 펄스보다 두 번째

00:14:01.580 --> 00:14:04.860
펄스에 대해 약간 더 멀리 떨어져 있을 것입니다.

00:14:04.860 --> 00:14:07.050
따라서 두 번째 펄스가 레이더로

00:14:07.060 --> 00:14:09.660
반환되는데 조금 더 오래 걸립니다.

00:14:09.660 --> 00:14:14.051
속도가 1밀리초 동안 일정하다고 가정할 때 세 번째 펄스는

00:14:14.051 --> 00:14:18.330
두 번째 펄스에 비해 반환되는 데 조금 더 오래 걸립니다.

00:14:18.860 --> 00:14:21.743
따라서 객체가 일정한 속도로 이동한다면,

00:14:21.743 --> 00:14:24.600
기본적으로 각각의 펄스를 이전의 펄스와

00:14:24.600 --> 00:14:27.460
시간상으로 동일한 양으로 지연시킵니다.

00:14:27.860 --> 00:14:31.980
각각의 지연된 펄스를 동일한 상대 시간에 샘플링하는 것은

00:14:31.990 --> 00:14:36.530
본질적으로는 송신 펄스를 고정 간격으로 샘플링하는 것입니다.

00:14:36.530 --> 00:14:42.730
이 작업은 고주파 송신 신호를 낮은 주파수로 치환합니다.

00:14:42.730 --> 00:14:45.350
그리고 이 낮은 주파수는 정확히 객체의

00:14:45.360 --> 00:14:48.130
속도에 의해 생성된 도플러 이동입니다.

00:14:48.130 --> 00:14:52.800
그래서 이 도플러 주파수를 속도로 변환할 수 있습니다.

00:14:53.730 --> 00:14:56.330
객체의 실제 속도가 증가함에 따라

00:14:56.340 --> 00:14:59.400
펄스 사이의 시간 지연도 증가하는데,

00:14:59.400 --> 00:15:02.400
그러면 도플러 이동도 증가합니다.

00:15:02.400 --> 00:15:04.780
이러한 방식으로 이 샘플링된 신호의 주파수를

00:15:04.800 --> 00:15:08.000
최소한 한 지점까지 살펴보면 속도를 추정할 수 있습니다.

00:15:08.460 --> 00:15:12.300
속도가 너무 증가하면 펄스 사이의

00:15:12.310 --> 00:15:17.460
시간 지연이 반 파장 이상으로 증가합니다.

00:15:17.460 --> 00:15:20.050
그렇게 되면 이 방법의 경우 도플러

00:15:20.060 --> 00:15:22.800
주파수가 다시 감소하기 시작합니다.

00:15:22.800 --> 00:15:26.850
그래서 펄스 사이에 정확히 반 파장의 지연을

00:15:26.870 --> 00:15:32.130
발생시키는 속도를 레이더의 최대 유효 속도라고 합니다.

00:15:32.130 --> 00:15:35.800
이 예제에서 펄스의 주파수는 2.8GHz입니다.

00:15:35.800 --> 00:15:39.400
약 5.5cm의 반 파장을 가지고 있죠.

00:15:39.400 --> 00:15:42.710
객체가 펄스 사이 또는 1밀리초 안에

00:15:42.730 --> 00:15:47.060
5.5cm 이상 이동할 수 없다는 의미입니다.

00:15:47.060 --> 00:15:50.109
따라서 최대 유효 속도는

00:15:50.109 --> 00:15:54.730
초당 약 55m, 즉 시속 120마일이 됩니다.

00:15:55.800 --> 00:15:58.708
결국 객체의 속도가 계속 증가하면

00:15:58.708 --> 00:16:01.646
펄스 사이의 지연도 계속 증가하여

00:16:01.646 --> 00:16:04.400
정확히 1파장으로 샘플링됩니다.

00:16:04.400 --> 00:16:05.980
그리고 그 시점에서 샘플링된

00:16:05.990 --> 00:16:08.330
신호의 주파수는 다시 0Hz가 됩니다.

00:16:08.330 --> 00:16:11.400
객체는 움직이지 않는 것처럼 보이네요.

00:16:11.400 --> 00:16:13.330
이것을 레이더 블라인드 속도라고 합니다.

00:16:13.330 --> 00:16:16.080
이 속도는 송신 신호 파장의 정수

00:16:16.090 --> 00:16:19.330
배수를 생성하는 속도에서 발생합니다.

00:16:21.130 --> 00:16:24.992
버퍼링된 반환 펄스를 보여주는 이 이미지로 돌아와 보면,

00:16:24.992 --> 00:16:28.336
지금까지 설명한 거리와 시선 속도에 대한 개념을

00:16:28.336 --> 00:16:30.060
함께 적용할 수 있습니다.

00:16:30.060 --> 00:16:33.360
거리는 고속 시간 축을 가로지르는 반환

00:16:33.370 --> 00:16:37.000
신호의 피크 시간을 확인하여 판단합니다.

00:16:37.000 --> 00:16:39.440
우리가 할 수 있는 두 가지 작업은

00:16:39.440 --> 00:16:42.667
정합 필터를 적용하고 여러 펄스를 통합하여

00:16:42.667 --> 00:16:45.730
SNR을 증가시키고 펄스를 좁히는 것입니다.

00:16:46.860 --> 00:16:49.562
시간 내에서 피크가 어디에 있는지 알고 나면

00:16:49.562 --> 00:16:52.280
우리는 그 시간에 각각의 펄스를 샘플링하고,

00:16:52.280 --> 00:16:54.707
그 결과 샘플링된 신호의 주파수를 찾아

00:16:54.707 --> 00:16:56.860
객체의 속도를 판단할 수 있습니다.

00:16:57.800 --> 00:17:00.643
시리즈의 두 번째 동영상을 떠올려 보세요.

00:17:00.643 --> 00:17:03.168
여러 개의 수신 안테나를 객체의 방향을

00:17:03.168 --> 00:17:06.460
판단하는 데 사용하는 방법에 대해 말씀드렸습니다.

00:17:06.460 --> 00:17:09.840
펄스 레이더의 경우도 똑같은 작업을 수행할 수 있고,

00:17:09.840 --> 00:17:13.196
시간이 지남에 따라 각각 여러 개의 펄스를 수신하고

00:17:13.196 --> 00:17:16.600
기록하는 여러 개의 수신 안테나도 가질 수 있습니다.

00:17:16.600 --> 00:17:20.876
결국 우리가 얻는 것은 데이터 큐브라고 하는 것인데,

00:17:20.876 --> 00:17:25.556
이는 거리, 시선 속도, 방향을 판단하는 데 사용할 수 있는

00:17:25.556 --> 00:17:27.200
정보의 세 축입니다.

00:17:27.200 --> 00:17:29.660
위상 배열 안테나를 주제로 한 다음 동영상에서

00:17:29.680 --> 00:17:32.060
데이터 큐브에 대해 자세히 알아보겠습니다.

00:17:32.330 --> 00:17:34.893
마지막으로 이 모든 개념이 정말 유용한 이유는,

00:17:34.893 --> 00:17:37.518
여러 객체가 동시에 시야에 들어오는 상황에서도

00:17:37.518 --> 00:17:39.460
효과적으로 작용한다는 사실입니다.

00:17:39.460 --> 00:17:41.939
MATLAB에서 펄스 도플러 레이더를 사용하여

00:17:41.939 --> 00:17:45.208
여러 객체의 거리와 속도를 판단하는 방법을 보여주는

00:17:45.208 --> 00:17:47.530
두 가지 예제를 링크에 남겨 뒀습니다.

00:17:47.530 --> 00:17:49.794
해당 내용들을 확인해 보시면 좋을 것 같습니다.

00:17:49.794 --> 00:17:51.152
우리가 방금 다룬 모든 내용을

00:17:51.152 --> 00:17:53.400
좀 더 현실적인 방법으로 보여드리기 때문입니다.

00:17:53.400 --> 00:17:56.210
실제로 탐지 임계값을 변경하고 정합 필터를 적용하면

00:17:56.230 --> 00:17:59.060
결과에 어떤 영향을 미치는지 확인할 수 있습니다.

00:17:59.060 --> 00:18:02.800
그리고 끝에는 여러 개의 펄스가 통합되어 있습니다.

00:18:02.800 --> 00:18:05.230
서로 다른 객체 3개의 거리에 해당하는

00:18:05.240 --> 00:18:07.930
3개의 피크를 명확하게 볼 수 있습니다.

00:18:07.930 --> 00:18:11.900
다른 예제에서도 비슷한 접근 방식을 취하지만,

00:18:11.910 --> 00:18:16.060
속도를 추정하기 위해 한 걸음 더 나아갑니다.

00:18:16.060 --> 00:18:18.330
저는 이 모든 개념이 정말 근사하다고 생각합니다.

00:18:18.330 --> 00:18:20.310
제가 아래에 제공한 링크들을 통해

00:18:20.320 --> 00:18:22.660
더 자세히 확인해 보시기를 바랍니다.

00:18:22.660 --> 00:18:24.930
오늘은 여기서 마치겠습니다.

00:18:24.930 --> 00:18:27.756
앞으로도 이러한 Tech Talk 동영상을 놓치고 싶지 않으시다면

00:18:27.756 --> 00:18:29.460
이 채널을 구독해 주시기 바랍니다.

00:18:29.460 --> 00:18:32.175
제가 운영하는 채널인 제어 시스템 강의에서도

00:18:32.175 --> 00:18:35.460
더 많은 제어 이론 주제를 다루고 있으니 확인해 주세요.

00:18:35.460 --> 00:18:36.860
시청해 주셔서 감사합니다.

00:18:36.860 --> 00:18:38.860
다음 동영상에서 다시 뵙겠습니다.

